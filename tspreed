#!/bin/sh

# Copyright (c) 2021 Nicholas Ivkovic.
# Licensed under the GNU General Public License version 3 or later. See ./LICENSE, or <https://gnu.org/licenses/gpl.html> if more recent, for details.
# This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.

# Finish tput session
endTput() {
	tput rmcup
	[ "$hidecursor" = true ] && tput cnorm
}

# Handle exit from signals 
catchExit() {
	endTput
	! [ "$quietexit" = true ] && echo "$wordnum/$wordstotal"
	exit 2
}

# Initialise tput output
initOutput() {
	tput clear
	# Set terminal-based vars
	termheight=$(tput lines)
	termwidth=$(tput cols)
	termxcenter=$(( termwidth/2 ))
	termycenter=$(( termheight/2 ))
	# Output pointers
	[ "$focus" = true ] && tput cup $(( termycenter-1 )) $termxcenter && printf "%s" "$pt1" && tput cup $(( termycenter+1 )) $termxcenter && printf "%s" "$pt2"
}

# Get current timestamp in ms
getDate() {
	echo $(( $(date +%s%N/1000000) ))
}

# Perform floating point calculation
# $1 Calculation to perform
calcFloat() {
	awk "BEGIN { print $1 }"
}

# Floor float to int
# $1 Float to floor
floorFloat() {
	echo "${1%.*}"
}

# Exit showing man refer
exitRefer() {
	echo "See 'man tspreed'" && exit 1
}

# Exit showing command usage
exitUsage() {
	echo "Usage: tspreed [-lqhifbBv] [-w wpm] [-n num] [-p style] [-c color]" && exitRefer
}

# Catch signals
trap "catchExit" 2      # SIGINT
trap "catchExit" 3      # SIGQUIT
trap "catchExit" 6      # SIGABRT
trap "catchExit" 14     # SIGALRM
trap "catchExit" 15     # SIGTERM
trap "initOutput" WINCH # Terminal resize

# Import configs
globalconfig="/etc/tspreed/tspreed.rc"
localconfig="${XDG_CONFIG_HOME:-$HOME/.config}/tspreed/tspreed.rc"
[ -f "$globalconfig" ] && . "$globalconfig"
[ -f "$localconfig" ] && . "$localconfig"

# Get passed args
while getopts ":w:n:qhilfp:bc:Bv" opt; do
	case "$opt" in
		w) wpm=$OPTARG;;
		n) numstart="$OPTARG";;
		l) lengthvary=true;;
		q) quietexit=true;;
		h) hidecursor=true;;
		i) proginfo=true;;
		f) focus=true;;
		p) focuspointer="$OPTARG";;
		b) focusbold=true;;
		c) focuscolor="$OPTARG";;
		B) breakposix=true;;
		v) echo "tspreed 2.0.0" && exit 0;;
		\?) echo "Invalid option '-$OPTARG'" && exitUsage;;
		:) echo "Option -$OPTARG requires an argument." && exitUsage;;
	esac
done

# Validate and set word speed
[ -z "$wpm" ] && echo "Words per minute not set" && exitRefer
! { [ "$wpm" -ge 1 ] && [ "$wpm" -le 60000 ]; } 2> /dev/null && echo "Invalid wpm '$wpm'" && exitRefer
# Validate and set nth word as starting word
[ -n "$numstart" ] && ! [ "$numstart" -ge 1 ] 2> /dev/null && echo "Invalid starting word position '$numstart'" && exitRefer 
[ -z "$numstart" ] && numstart=1
# Validate focus letter options
if [ "$focus" = true ]; then
	# Validate and set focus letter pointers
	pt1=" " && pt2=" "
	[ -n "$focuspointer" ] && [ "$focuspointer" != "none" ] && case "$focuspointer" in
		line) pt1="|" && pt2="|";;
		point) pt1="v" && pt2="^";;
		*) echo "Invalid focus letter pointer '$focuspointer'" && exitRefer;;
	esac
	# Validate focus letter color
	[ -n "$focuscolor" ] && ! { [ "$focuscolor" -ge 0 ] && [ "$focuscolor" -le 255 ]; } 2> /dev/null && echo "Invalid focus letter color '$focuscolor'" && exitRefer
fi

# Get input
input=
while read -r inp; do
	input="$input$inp "
done

# Init presentation
tput smcup
[ "$hidecursor" = true ] && tput civis
initOutput
wordlenaverage=5 # Based on average English word length of 5.1 letters
wordstotal=$(echo "$input" | wc -w | tr -d "[:space:]")
wordnum=0
firstword=true
startdate=

# Present
for word in $input; do
	# Init word 
	startdate=$(getDate)
	wordnum=$(( wordnum+1 ))
	[ "$wordnum" -lt "$numstart" ] && continue
	wordlen=${#word}

	# Focus letter highlighting
	if [ "$focus" = true ]; then
		# Find index of focus letter
		case "$wordlen" in
			1|2)         focusindex=1;;
			3|4|5)       focusindex=2;;
			6|7|8|9)     focusindex=3;;
			10|11|12|13) focusindex=4;;
			*)           focusindex=5;;
		esac
		# Determine if word length exceeds terminal width
		[ $(( wordlen+termxcenter-focusindex+1 )) -gt "$termwidth" ] && wordlenexceed=true
		# Set horizontal position of word
		wordx=$(( termxcenter-focusindex+1 ))
		# Highlight focus letter
		wordstart=$([ "$focusindex" -gt 1 ] && echo "$word" | cut -c 1-$(( focusindex - 1 )))
		wordend=$([ "$wordlen" -gt 1 ] && echo "$word" | cut -c $(( focusindex + 1 ))-"$wordlen")
		focusletter=$(echo "$word" | cut -c "$focusindex")
		[ "$focusbold" = true ] && focusletter="$(tput bold)$focusletter"
		[ -n "$focuscolor" ] && focusletter="$(tput setaf "$focuscolor")$focusletter"
		[ "${#focusletter}" -ne 1 ] && focusletter="$focusletter$(tput sgr0)"
		word="$wordstart$focusletter$wordend"
	else
		# Set horizontal position of word
		[ $(( wordlen+termxcenter-(wordlen/2) )) -gt "$termwidth" ] && wordlenexceed=true && wordx=0 || wordx=$(( termxcenter-(wordlen/2) ))
	fi

	# Output word
	tput cup $termycenter 0 && tput el && tput cup $termycenter $wordx && printf "%s" "$word"
	# Output presentation information
	[ "$proginfo" = true ] && tput cup home && tput el && printf "%s/%s\t%s%%" "$wordnum" "$wordstotal" "$(( (wordnum*100)/wordstotal ))"
	# Move cursor to bottom left
	tput cup "$termheight" 0

	# Set sleep time (ms)
	sleeptime=$(calcFloat "1000/($wpm/60)") && sleeptimeint=$(floorFloat "$sleeptime")
	if [ "$firstword" = true ]; then
		firstword=false && [ "$sleeptimeint" -lt 1000 ] && sleeptime=1000 && sleeptimeint=1000
	elif [ "$lengthvary" = true ]; then
		[ "$wordlen" -gt "$wordlenaverage" ] && sleeptime=$(calcFloat "$sleeptime*($wordlen/$wordlenaverage)") || sleeptime=$(calcFloat "$sleeptime*($wordlen/($wordlen+1))")
		sleeptimeint=$(floorFloat "$sleeptime")
	fi
	# Sleep
	wordtime=$(( $(getDate)-startdate ))
	if [ "$sleeptimeint" -gt "$wordtime" ]; then
		if [ "$breakposix" = true ]; then
			sleep "$(calcFloat "($sleeptime-$wordtime)/1000")"
		else
			sleepdate=$(( $(getDate)+sleeptimeint-wordtime ))
			while [ "$(getDate)" -lt "$sleepdate" ]; do
				:
			done
		fi
	fi

	# Re-init output if word length exceeds terminal width
	[ "$wordlenexceed" = true ] && [ "$wordnum" -lt "$wordstotal" ] && initOutput
done

# Finish
sleep 1 && endTput && exit 0
